<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <style>
	#body{
	   		background-image: url('https://github.com/saikamal33/mini-game/blob/master/background.jpg');
    		background-size: cover;
		  	background-position: center;
		  	background-repeat: no-repeat;
		  	height: 100vh;
		  	margin: 0;
		  	padding: 0;
			background-attachment: fixed;
	}
	#game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #f0f0f0;
            padding: 20px;
            box-sizing: border-box;
        }
        #tetris {
            border: 2px solid #333;
            background-color: #000;
            width: 288px; /* 12x20 grid, 24px blocks (CSS size) */
            height: 480px;
            touch-action: none; /* Prevent default touch behaviors */
        }
        #score {
            font-family: Arial, sans-serif;
            font-size: 20px;
            margin: 10px 0;
            color: #333;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            max-width: 288px;
            justify-content: center;
            padding: 12px;
            background-color: #222;
            border-radius: 8px;
            width: 100%;
            box-sizing: border-box;
            margin-top: 10px; /* Close to the score and canvas */
        }
        #controls button {
            width: 60px;
            height: 60px;
            padding: 0;
            font-size: 0; /* Hide text, only SVGs */
            cursor: pointer;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 8px;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        #controls button:active {
            background-color: #45a049;
        }
        #controls button svg {
            width: 28px;
            height: 28px;
            fill: #fff;
        }
        @media (min-width: 768px) {
            #controls {
                display: none; /* Hide buttons on PC */
            }
            #tetris {
                width: 360px; /* Larger canvas for desktop */
                height: 600px;
            }
            #game-container {
                justify-content: center;
                gap: 20px;
            }
            #score {
                font-size: 24px;
            }
        }
        @media (max-width: 500px) {
            #tetris {
                width: 230px; /* 12x20 grid, 19.2px blocks for mobile */
                height: 384px;
            }
            #controls {
                max-width: 230px;
                gap: 10px;
                padding: 10px;
            }
            #controls button {
                width: 48px;
                height: 48px;
            }
            #controls button svg {
                width: 24px;
                height: 24px;
            }
            #score {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div>
            <canvas id="tetris"></canvas>
            <div id="score">Score: <span id="score-value">0</span></div>
            <div id="controls">
                <button onclick="playerMove(-1)">
                    <svg viewBox="0 0 24 24">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <button onclick="playerMove(1)">
                    <svg viewBox="0 0 24 24">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
                <button onclick="playerDrop()">
                    <svg viewBox="0 0 24 24">
                        <path d="M6 9l6 6 6-6"/>
                    </svg>
                </button>
                <button onclick="playerRotate()">
                    <svg viewBox="0 0 24 24">
                        <path d="M14 3a7 7 0 00-7 7h2l-3 3-3-3h2a9 9 0 019 9v1h2v-1a11 11 0 00-11-11h-2l3-3 3 3h-2a7 7 0 007-7z"/>
                    </svg>
                </button>
                <button onclick="playerResetGame()">
                    <svg viewBox="0 0 24 24">
                        <path d="M17 3.34A10 10 0 1 1 2 12H0a12 12 0 1 0 12 12 12 12 0 0 0 12-12h-2a10 10 0 0 1-5-1.34z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const scoreElement = document.getElementById('score-value');
        let gameOver = false;

        // Handle high-DPI displays
        const pixelRatio = window.devicePixelRatio || 1;
        let BLOCK_SIZE = window.innerWidth < 500 ? 19.2 : 24;
        let canvasWidth = window.innerWidth < 500 ? 230 : 288;
        let canvasHeight = window.innerWidth < 500 ? 384 : 480;

        if (window.innerWidth >= 768) {
            canvasWidth = 360;
            canvasHeight = 600;
            BLOCK_SIZE = 30;
        }

        // Set canvas display size (CSS) and internal resolution
        canvas.style.width = canvasWidth + 'px';
        canvas.style.height = canvasHeight + 'px';
        canvas.width = canvasWidth * pixelRatio;
        canvas.height = canvasHeight * pixelRatio;
        context.scale(pixelRatio, pixelRatio);

        const arena = createMatrix(12, 20);
        const player = {
            pos: { x: 0, y: 0 },
            matrix: null,
            type: null,
            score: 0,
            rotationState: 0
        };

        const colors = [
            null,
            '#FF0D72', // I - Vivid Pink
            '#0DC2FF', // O - Bright Cyan
            '#0DFF72', // T - Lime Green
            '#F538FF', // S - Hot Pink
            '#FF8E0D', // Z - Orange
            '#FFE138', // J - Yellow
            '#3877FF', // L - Blue
            '#FF5555', // Extra 1 - Red
            '#55FF55', // Extra 2 - Green
            '#AA00FF', // Extra 3 - Purple
            '#FFAA00', // Extra 4 - Amber
            '#00AAAA'  // Extra 5 - Teal
        ];

        const tetrominoes = [
            [[1, 1, 1, 1]], // I
            [[2, 2], [2, 2]], // O
            [[0, 3, 0], [3, 3, 3]], // T
            [[0, 4, 4], [4, 4, 0]], // S
            [[5, 5, 0], [0, 5, 5]], // Z
            [[6, 0, 0], [6, 6, 6]], // J
            [[0, 0, 7], [7, 7, 7]], // L
            [[8, 8, 8], [0, 8, 0]], // Extra 1 - T-like
            [[9, 0, 9], [9, 9, 9]], // Extra 2 - L-like
            [[0, 10, 0], [10, 10, 10]], // Extra 3 - T-like
            [[11, 11, 0], [0, 11, 11]], // Extra 4 - Z-like
            [[0, 12, 12], [12, 12, 0]] // Extra 5 - S-like
        ];

        const wallKicksI = [
            [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
            [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
            [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]],
            [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
            [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
            [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
            [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
            [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]]
        ];

        const wallKicksOther = [
            [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
            [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
            [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
            [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
            [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
            [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
            [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
            [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]]
        ];

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) matrix.push(new Array(w).fill(0));
            return matrix;
        }

        function createPiece(type) {
            return tetrominoes[type].map(row => [...row]);
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (!arena[y + o.y] || arena[y + o.y][x + o.x] !== 0)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        function playerDrop() {
            if (gameOver) return;
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            if (gameOver) return;
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
            }
        }

        function playerRotate() {
            if (gameOver) return;
            if (player.type === 1) return; // Skip rotation for O-tetromino
            const originalMatrix = player.matrix.map(row => [...row]);
            const originalPos = { x: player.pos.x, y: player.pos.y };
            rotate(player.matrix);
            const wallKicks = player.type === 0 ? wallKicksI : wallKicksOther;
            let rotated = false;
            for (let kick of wallKicks[player.rotationState]) {
                player.pos.x = originalPos.x + kick[0];
                player.pos.y = originalPos.y + kick[1];
                if (!collide(arena, player)) {
                    rotated = true;
                    break;
                }
            }
            if (rotated) {
                player.rotationState = (player.rotationState + 1) % 4;
            } else {
                player.matrix = originalMatrix;
                player.pos.x = originalPos.x;
                player.pos.y = originalPos.y;
            }
        }

        function rotate(matrix) {
            const N = matrix.length;
            const M = matrix[0].length;
            const result = Array.from({ length: M }, () => Array(N).fill(0));
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < M; x++) {
                    result[x][N - 1 - y] = matrix[y][x];
                }
            }
            matrix.length = 0;
            matrix.push(...result);
        }

        function playerReset() {
            const type = Math.floor(Math.random() * tetrominoes.length);
            player.matrix = createPiece(type);
            player.type = type;
            player.rotationState = 0;
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(arena, player)) {
                gameOver = true; // Set game over instead of clearing board
            }
        }

        function playerResetGame() {
            arena.forEach(row => row.fill(0));
            player.score = 0;
            gameOver = false; // Reset game over state
            updateScore();
            playerReset();
        }

        function arenaSweep() {
            let rowCount = 1;
            outer: for (let y = arena.length - 1; y >= 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                player.score += rowCount * 10;
                rowCount *= 2;
            }
            updateScore();
        }

        function updateScore() {
            scoreElement.textContent = player.score;
        }

        function drawGrid() {
            context.strokeStyle = '#666';
            context.lineWidth = 0.5 / pixelRatio; // Adjust for sharpness
            for (let x = 0; x <= 12; x++) {
                context.beginPath();
                context.moveTo(x * BLOCK_SIZE, 0);
                context.lineTo(x * BLOCK_SIZE, 20 * BLOCK_SIZE);
                context.stroke();
            }
            for (let y = 0; y <= 20; y++) {
                context.beginPath();
                context.moveTo(0, y * BLOCK_SIZE);
                context.lineTo(12 * BLOCK_SIZE, y * BLOCK_SIZE);
                context.stroke();
            }
        }

        function draw() {
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawMatrix(arena, { x: 0, y: 0 });
            if (!gameOver) {
                drawMatrix(player.matrix, player.pos);
            }
            if (gameOver) {
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvasWidth, canvasHeight);
                context.fillStyle = '#FFF';
                context.font = `${BLOCK_SIZE * 1.5}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText('Game Over', canvasWidth / 2, canvasHeight / 2 - BLOCK_SIZE);
                context.font = `${BLOCK_SIZE}px Arial`;
                context.fillText('Tap Reset to Play Again', canvasWidth / 2, canvasHeight / 2 + BLOCK_SIZE);
            }
        }

        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = colors[value];
                        context.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        context.strokeStyle = '#fff';
                        context.lineWidth = 0.2 / pixelRatio; // Adjust for sharpness
                        context.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }

        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;

        function update(time = 0) {
            if (gameOver) {
                draw(); // Draw game over screen
                return; // Stop game loop
            }
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }
            draw();
            requestAnimationFrame(update);
        }

        document.addEventListener('keydown', event => {
            if (gameOver && event.key !== 'r' && event.key !== 'R') return;
            if (event.key === 'ArrowLeft') {
                playerMove(-1);
            } else if (event.key === 'ArrowRight') {
                playerMove(1);
            } else if (event.key === 'ArrowDown') {
                playerDrop();
            } else if (event.key === 'ArrowUp') {
                playerRotate();
            } else if (event.key === 'r' || event.key === 'R') {
                playerResetGame();
            }
        });

        playerReset();
        update();
    </script>
</body>
</html>
